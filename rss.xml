<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kuta's Blog</title>
    <description>Nick Kuta,全栈工程师,极客,热爱技术&amp;设计。很高兴能在这里与你分享我对技术和生活的思考。</description>
    <link>http://localhost:4000//</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 03 Dec 2019 14:06:10 +0800</pubDate>
    <lastBuildDate>Tue, 03 Dec 2019 14:06:10 +0800</lastBuildDate>
    <generator>Jekyll v3.8.6</generator>
    
      <item>
        <title>Seven porridge</title>
        <description>&lt;blockquote&gt;
  &lt;h1 id=&quot;七人分粥&quot;&gt;七人分粥&lt;/h1&gt;
&lt;/blockquote&gt;

&lt;p&gt;  有七个人曾经住在一起，每天分一大桶粥。要命的是，粥每天都是不够的。  &lt;br /&gt;
  &lt;b&gt;一开始&lt;/b&gt;，他们抓阄决定谁来分粥，每天轮一个。于是乎每周下来，他们只有一天是饱的，就是自己分粥的那一天。&lt;br /&gt;
  &lt;b&gt;后来&lt;/b&gt;他们开始推选出一个道德高尚的人出来分粥。强权就会产生腐败，大家开始挖空心思去讨好他，贿赂他，搞得整个小团体乌烟障气。&lt;br /&gt;
  &lt;b&gt;然后&lt;/b&gt;大家开始组成三人的分粥委员会及四人的评选委员会，但他们常常互相攻击，扯皮下来，粥吃到嘴里全是凉的。&lt;br /&gt;
  &lt;b&gt;最后&lt;/b&gt;想出来一个方法：轮流分粥，但分粥的人要等其它人都挑完后拿剩下的最后一碗。为了不让自己吃到最少的，每人都尽量分得平均，就算不平，也只能认了。大家快快乐乐，和和气气，日子越过越好。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;PS:&lt;/em&gt;&lt;/strong&gt; 同样是七个人，不同的分配制度，就会有不同的风气。所以一个单位如果有不好的工作习气，一定是机制问题，一定是没有完全公平公正公开，没有严格的奖勤罚懒。如何制订这样一个制度，是每个领导需要考虑的问题。&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Dec 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/12/03/seven-porridge.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/12/03/seven-porridge.html</guid>
        
        <category>story</category>
        
        <category>manage</category>
        
        
      </item>
    
      <item>
        <title>Doctor</title>
        <description>&lt;blockquote&gt;
  &lt;h1 id=&quot;博士&quot;&gt;博士&lt;/h1&gt;
&lt;/blockquote&gt;

&lt;p&gt;  有一个博士分到一家研究所，成为学历最高的一个人。&lt;br /&gt;
  有一天他到单位后面的小池塘去钓鱼，正好正副所长在他的一左一右，也在钓鱼。&lt;br /&gt;
  他只是微微点了点头，这两个本科生，有啥好聊的呢？  &lt;br /&gt;
  不一会儿，正所长放下钓竿，伸伸懒腰，蹭蹭蹭从水面上如飞地走到对面上厕所。  &lt;br /&gt;
  博士眼睛睁得都快掉下来了。水上飘？不会吧？这可是一个池塘啊。&lt;br /&gt;
  正所长上完厕所回来的时候，同样也是蹭蹭蹭地从水上飘回来了。&lt;br /&gt;
  怎么回事？博士生又不好去问，自己是博士生哪！&lt;br /&gt;
  过一阵，副所长也站起来，走几步，蹭蹭蹭地飘过水面上厕所。这下子博士更是差点昏倒：不会吧，到了一个江湖高手集中的地方？&lt;br /&gt;
  博士生也内急了。这个池塘两边有围墙，要到对面厕所非得绕十分钟的路，而回单位上又太远，怎么办？&lt;br /&gt;
  博士生也不愿意去问两位所长，憋了半天后，也起身往水里跨：我就不信本科生能过的水面，我博士生不能过。&lt;br /&gt;
  只听咚的一声，博士生栽到了水里。&lt;br /&gt;
  两位所长将他拉了出来，问他为什么要下水，他问：”为什么你们可以走过去呢？”&lt;br /&gt;
  两所长相视一笑：”这池塘里有两排木桩子，由于这两天下雨涨水正好在水面下。我们都知道这木桩的位置，所以可以踩着桩子过去。你怎么不问一声呢？”&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;PS:&lt;/em&gt;&lt;/strong&gt; 学历代表过去，只有学习力才能代表将来。尊重经验的人，才能少走弯路。一个好的团队，也应该是学习型的团队。&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Dec 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/12/03/doctor.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/12/03/doctor.html</guid>
        
        <category>story</category>
        
        <category>manage</category>
        
        
      </item>
    
      <item>
        <title>Bash shell</title>
        <description>&lt;blockquote&gt;
  &lt;h1 id=&quot;bash-shell编程入门&quot;&gt;Bash Shell编程入门&lt;/h1&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-shell是什么&quot;&gt;1 Shell是什么？&lt;/h2&gt;
&lt;p&gt; shell本身是一个命令解释器，介于操作系统的内核（kernel）态和用户态之间，可以执行系统调用及系统命令等，让用户以此来与操作系统实现互动。同时，它也用来指一种计算机程序语言（类似于C、Python等）。一个shell程序一般被称为一个脚本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Shell语言的流派&lt;/strong&gt;&lt;br /&gt;
目前，shell主要有两大流派：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;sh:&lt;/li&gt;
  &lt;li&gt;burne shell (sh)&lt;/li&gt;
  &lt;li&gt;burne again shell (bash)&lt;/li&gt;
  &lt;li&gt;csh:&lt;/li&gt;
  &lt;li&gt;c shell (csh)&lt;/li&gt;
  &lt;li&gt;tc shell (tcsh)&lt;/li&gt;
  &lt;li&gt;korn shell (ksh)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前，大部分Linux系统预设的shell都是bash。&lt;br /&gt;
Ubuntu16.04提供的shell环境（登录成功后默认使用bash）：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;slot@slot-ubt:~&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/shells
&lt;span class=&quot;c&quot;&gt;# /etc/shells: valid login shells &lt;/span&gt;
/bin/sh 
/bin/dash 
/bin/bash 
/bin/rbash 
slot@slot-ubt:~&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Mac OS提供的shell环境：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/shells 
&lt;span class=&quot;c&quot;&gt;# List of acceptable shells for chpass(1).&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Ftpd will not allow users to connect who are not using &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# one of these shells. &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 
/bin/bash 
/bin/csh 
/bin/ksh 
/bin/sh 
/bin/tcsh 
/bin/zsh &lt;span class=&quot;c&quot;&gt;# zsh系本文作者自己安装 &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;一个极简的bash demo: hello_world.sh&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash &lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Here is comment &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行 &lt;br /&gt;
方法1: 直接使用bash解释器来解释执行：&lt;br /&gt;
&lt;em&gt;bash hello_world.sh&lt;/em&gt; &lt;br /&gt;
或者：&lt;br /&gt;
&lt;em&gt;sh hello_world.sh&lt;/em&gt; &lt;br /&gt;
方法2: 先将文件属性改为可执行状态：&lt;br /&gt;
&lt;em&gt;chmod +x hello_world.sh&lt;/em&gt; &lt;br /&gt;
或者：&lt;br /&gt;
&lt;em&gt;chmod 777 hello_world.sh&lt;/em&gt; &lt;br /&gt;
再直接执行：&lt;br /&gt;
&lt;em&gt;./hello_world.sh&lt;/em&gt; &lt;br /&gt;
输出&lt;br /&gt;
&lt;em&gt;Hello World!&lt;/em&gt; &lt;br /&gt;
解释&lt;br /&gt;
#!用来指定执行该脚本的解释器，后面的/bin/bash表明指定/bin目录下的bash程序来解释执行该脚本文件。 &lt;br /&gt;
#开头的是注释行(#!除外)，shell中只有单行注释。 &lt;br /&gt;
echo “Hello World!” 即用echo命令输出字符串”Hello World!”到终端显示器。 &lt;br /&gt;
补充知识: 文件的属性&lt;br /&gt;
通过ls -l命令可以查看文件的属性，例如查看新建文件test.sh的属性：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;slot@slot-ubt:~&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;test.sh 
slot@slot-ubt:~&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; test.sh 
&lt;span class=&quot;nt&quot;&gt;-rw-rw-r--&lt;/span&gt; 1 slot slot 0 12月 21 15:40 test.sh 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看到，一般新建文件的默认属性是-rw-rw-r–，即644，不具有可执行属性x，可使用chmod命令来改变文件属性（修改默认属性则使用umask命令），例如将文件test.sh的属性改为可读可写可执行(rwx: 4 + 2 + 1 = 7)：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;slot@slot-ubt:~&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chmod &lt;/span&gt;777 test.sh 
slot@slot-ubt:~&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; test.sh 
&lt;span class=&quot;nt&quot;&gt;-rwxrwxrwx&lt;/span&gt; 1 slot slot 0 12月 21 15:40 test.sh 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-bash中的变量&quot;&gt;2 Bash中的变量&lt;/h2&gt;
&lt;h3 id=&quot;21-变量的定义与赋值&quot;&gt;2.1 变量的定义与赋值&lt;/h3&gt;
&lt;p&gt;不像C、Java等静态语言需要先声明然后才能使用，而是和Python等动态语言类似，Bash变量在使用时直接定义，例如：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;my_bash_var&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;this is my bash var&quot;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;＝两边不能有空格！否则就是语法错误了。&lt;/li&gt;
  &lt;li&gt;Bash变量命名只能使用字母，下划线和数字，并且不能以数字开头。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22-变量的引用&quot;&gt;2.2 变量的引用&lt;/h3&gt;
&lt;p&gt;使用已定义的变量时，只要在变量名前面加$符号即可:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$my_bash_var&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;或者使用${var_name}的形式，{}是可选的，主要是帮助解释器更好地识别变量的边界(推荐)：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;my_bash_var&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意’‘和”“的区别：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;’‘ ：单引号里的任何字符都会原样输出，单引号中对变量引用是无效的，且单引号中不能出现单引号（对单引号使用转义符也不行）；&lt;/li&gt;
  &lt;li&gt;”“：双引号里可以引用变量，可以出现转义字符。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实例：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello&quot;&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'a is : $a'&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;a is : &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$a&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 
Output:
a is : &lt;span class=&quot;nv&quot;&gt;$a&lt;/span&gt; 
a is : hello 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;只读变量&lt;br /&gt;
使用 readonly 命令可以将变量限定为只读变量，这与 C 语言中的 const 常量类型的情况相同.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;a_var&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello&quot;&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;readonly &lt;/span&gt;a_var 
&lt;span class=&quot;nv&quot;&gt;a_var&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;world&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Output: bash: read-only variable: a_var &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;删除变量&lt;br /&gt;
使用 unset 命令可以删除变量，但是不能删除只读变量。&lt;br /&gt;
变量被删除后不能再次使用。&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;my_var&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;haha&quot;&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;unset &lt;/span&gt;my_var 
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;my_var&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 变量my_var已被删除，没有任何输出 &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;23-变量的类型&quot;&gt;2.3 变量的类型&lt;/h3&gt;
&lt;p&gt;诸如C、Java、Python等这些高级语言中的变量是有类型的，例如数字类型（整型、浮点型等）、字符串类型、布尔类型，面向对象语言中还有引用类型等。但是，在Bash中，并不对变量区分类型。&lt;br /&gt;
本质上来说，Bash变量都是字符串。但是依赖于上下文，Bash也允许比较操作和算术操作。决定这些的关键因素是变量中的值是否只有数字，只有当变量是纯数字时，该变量才是“数字类型的”，否则就是字符串类型的。&lt;br /&gt;
另外，注意Bash中的数字默认的是十进制，八进制需要以0开头，十六进制以0x开头。&lt;br /&gt;
纯数字变量是“数字变量”：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1234 
&lt;span class=&quot;nb&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;a+=1&quot;&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Output: 1235 &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;数字＋字符串：字符串变量，字符串变量不能进行数学运算&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/12/BB&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 将12替换为BB &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Output: BB35 &lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;b+=1&quot;&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Output:1 &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;将变量中的非数字字符替换为数字，得到数字变量&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;BB34 
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Output: BB34 &lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/BB/12&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 将BB替换为12 &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Output: 1234 &lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;d+=1&quot;&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Output: 1235 &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;空变量+数字：数字变量&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 变量e定义为空值 &lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Output: 没有任何输出 &lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;e+=1&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 空值 + 1 &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Output: 1 &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;未定义的变量+数字：数字变量&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 变量f未定义 &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;f = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$f&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Output: f = &lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;f+=1&quot;&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;f = &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Output: f = 1 &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;24-变量的作用域&quot;&gt;2.4 变量的作用域&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;局部变量(local variables)：这种变量只有在变量所在的代码块或者函数中才可见，需要使用local声明；&lt;/li&gt;
  &lt;li&gt;全局变量：Bash中用户自定义的普通变量默认是全局变量，可以在本文件中的其它位置引用；&lt;/li&gt;
  &lt;li&gt;环境变量(environmental variables)：所有的程序（包括shell启动的程序）都能访问环境变量。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果一个shell脚本设置了环境变量,需要用 export 命令来通知脚本的环境。&lt;br /&gt;
更多关于环境变量的知识可以参考以下文章：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/ac2bc0ad3d74&quot;&gt;Linux环境变量总结&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/f7d4a821d292&quot;&gt;linux入门之环境变量与文件查找&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-bash中的运算符&quot;&gt;3 Bash中的运算符&lt;/h2&gt;
&lt;p&gt;Bash支持的运算符有：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;数学运算符&lt;/li&gt;
  &lt;li&gt;关系运算符&lt;/li&gt;
  &lt;li&gt;布尔运算符&lt;/li&gt;
  &lt;li&gt;逻辑运算符&lt;/li&gt;
  &lt;li&gt;字符串运算符&lt;/li&gt;
  &lt;li&gt;文件测试运算符&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;31-数学运算符&quot;&gt;3.1 数学运算符&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;数学运算符 &lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;加法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;减法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;*&lt;/td&gt;
      &lt;td&gt;乘法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/&lt;/td&gt;
      &lt;td&gt;除法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;%&lt;/td&gt;
      &lt;td&gt;取余&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;=&lt;/td&gt;
      &lt;td&gt;赋值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;==&lt;/td&gt;
      &lt;td&gt;相等测试，相等则返回true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!=&lt;/td&gt;
      &lt;td&gt;不相等测试，不相等则返回true&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;注意： 乘号*前边必须加反斜杠 \ 才能实现乘法运算&lt;/p&gt;

&lt;h3 id=&quot;32-关系运算符&quot;&gt;3.2 关系运算符&lt;/h3&gt;
&lt;p&gt;关系运算符只支持数字，不支持字符串，除非字符串的值是数字&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;关系运算符&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-eq&lt;/td&gt;
      &lt;td&gt;(equal) 检测两个数是否相等，相等则返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-ne&lt;/td&gt;
      &lt;td&gt;(not equal）检测两个数是否相等，不相等则返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-gt&lt;/td&gt;
      &lt;td&gt;(greater than）检测左边的数是否大于右边的，如果是，则返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-lt&lt;/td&gt;
      &lt;td&gt;(lower than) 检测左边的数是否小于右边的，如果是，则返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-ge&lt;/td&gt;
      &lt;td&gt;(greater equal）检测左边的数是否大于等于右边的，如果是，则返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-le&lt;/td&gt;
      &lt;td&gt;(lower equal) 检测左边的数是否小于等于右边的，如果是，则返回 true&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;33-布尔运算符&quot;&gt;3.3 布尔运算符&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;布尔运算符&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-a&lt;/td&gt;
      &lt;td&gt;与运算，两个表达式都为 true 才返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-o&lt;/td&gt;
      &lt;td&gt;或运算，有一个表达式为 true 则返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!&lt;/td&gt;
      &lt;td&gt;非运算，表达式为 true 则返回 false，否则返回 true&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;34-逻辑运算符&quot;&gt;3.4 逻辑运算符&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;逻辑运算符&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
      &lt;td&gt;逻辑与&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;||&lt;/td&gt;
      &lt;td&gt;逻辑或&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;35-字符串运算符&quot;&gt;3.5 字符串运算符&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;字符串运算符&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;举例 (a=”abc” b=”def”)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;=&lt;/td&gt;
      &lt;td&gt;检测两个字符串是否相等，相等返回 true&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[ $a = $b ]&lt;/code&gt; 返回 false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!=&lt;/td&gt;
      &lt;td&gt;检测两个字符串是否相等，不相等返回 true&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[ $a != $b ]&lt;/code&gt; 返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-z&lt;/td&gt;
      &lt;td&gt;检测字符串长度是否为0，为0返回 true&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[ -z $a ]&lt;/code&gt; 返回 false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-n&lt;/td&gt;
      &lt;td&gt;检测字符串长度是否为0，不为0返回 true&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[ -n $a ]&lt;/code&gt; 返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;str_name&lt;/td&gt;
      &lt;td&gt;检测字符串是否为空，不为空返回 true&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[ $a ]&lt;/code&gt; 返回 true&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;36-文件测试运算符&quot;&gt;3.6 文件测试运算符&lt;/h3&gt;
&lt;p&gt;文件测试运算符用于检测 Unix 文件的各种属性&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;文件测试运算符&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-b file&lt;/td&gt;
      &lt;td&gt;检测文件是否是块设备文件，如果是，则返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-c file&lt;/td&gt;
      &lt;td&gt;检测文件是否是字符设备文件，如果是，则返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-d file&lt;/td&gt;
      &lt;td&gt;检测文件是否是目录，如果是，则返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-f file&lt;/td&gt;
      &lt;td&gt;检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-g file&lt;/td&gt;
      &lt;td&gt;检测文件是否设置了 SGID 位，如果是，则返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-k file&lt;/td&gt;
      &lt;td&gt;检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p fill&lt;/td&gt;
      &lt;td&gt;检测文件是否是命名管道，如果是，则返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-u file&lt;/td&gt;
      &lt;td&gt;检测文件是否设置了 SUID 位，如果是，则返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-r file&lt;/td&gt;
      &lt;td&gt;检测文件是否可读，如果是，则返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-w file&lt;/td&gt;
      &lt;td&gt;检测文件是否可写，如果是，则返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-x file&lt;/td&gt;
      &lt;td&gt;检测文件是否可执行，如果是，则返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-s file&lt;/td&gt;
      &lt;td&gt;检测文件是否为空（文件大小是否大于0），不为空返回 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-e file&lt;/td&gt;
      &lt;td&gt;检测文件（包括目录）是否存在，如果是，则返回 true&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;4-bash的控制流&quot;&gt;4 Bash的控制流&lt;/h2&gt;
&lt;h3 id=&quot;41-条件语句&quot;&gt;4.1 条件语句&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;4.1.1 if语句&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; condition &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;then 
	&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;command 
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;if-else&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; condition &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;then 
	&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;command 
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else 
	&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;command 
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;if-elif-else&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; condition1 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;then 
	&lt;/span&gt;command1 
&lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; condition2 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; 
	command2 
&lt;span class=&quot;k&quot;&gt;else 
	&lt;/span&gt;commandN 
&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意：&lt;br /&gt;
勿忘最后的fi（if的反向拼写）!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.1.2 case语句&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; 
	&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$condition1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
		command1 
	&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt; 

	&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$condition2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
		command2 
	&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt; 
	&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 这里相当于C中case语句的default &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;esac&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对变量使用”“并不是强制的，因为不会发生单词分离;&lt;/li&gt;
  &lt;li&gt;每句测试行,都以右小括号)结尾;&lt;/li&gt;
  &lt;li&gt;每个条件块都以两个分号;;结尾（作用类似C中的break）;&lt;/li&gt;
  &lt;li&gt;case 块的结束以 esac(case 的反向拼写)结尾.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;42-循环语句&quot;&gt;4.2 循环语句&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;4.2.1 for语句&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;var &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;item1 item2 ... itemN 
&lt;span class=&quot;k&quot;&gt;do 
	&lt;/span&gt;command1 
	command2 
	... 
	commandN 
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意： &lt;br /&gt;
在循环的每次执行中，var将顺序的存取 list （i.e. item1 … itemN）中列出的变量。&lt;br /&gt;
C风格的for循环:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt; EXP1&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; EXP2&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; EXP3 &lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;do 
	&lt;/span&gt;command1 
	command2 
	command3 
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意: (())中对变量的引用可以不加$&lt;br /&gt;
&lt;strong&gt;4.2.2 while语句&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; condition &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;do 
	&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;command 
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;C风格的while循环:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt; condition &lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;do 
	&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;command 
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意: (())中对变量的引用同样可以不加$&lt;br /&gt;
&lt;strong&gt;4.2.3 until语句&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;until&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; condition-is-true &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;do 
	&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;command 
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意：   
util结构在循环的顶部判断条件,并且如果条件一直为 false 那就一直循环下去，直到条件为真才结束循环(与 while 相反)。&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;5-bash支持的编程模型&quot;&gt;5 Bash支持的编程模型&lt;/h2&gt;
&lt;p&gt;Bash只支持过程式的编程模型，不支持面向对象和函数式等高级编程模型，更不支持对高级设计模式的实现。所以，如果要实现比较复杂的功能，还是使用Perl、Python或者Ruby等高级语言吧。&lt;/p&gt;
&lt;h3 id=&quot;51-bash的传参机制&quot;&gt;5.1 Bash的传参机制&lt;/h3&gt;
&lt;p&gt;shell通过位置参数（positional parameters）来给脚本文件传递参数，就是从命令行中传进来的参数,&lt;code class=&quot;highlighter-rouge&quot;&gt;$0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;$1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;$2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;$3&lt;/code&gt;… 其中：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$0&lt;/code&gt; 是该脚本文件的名字&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$1&lt;/code&gt; 是第一个参数, &lt;code class=&quot;highlighter-rouge&quot;&gt;$2&lt;/code&gt; 是第 2 个参数…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$9&lt;/code&gt; 以后就需要大括号了,如 &lt;code class=&quot;highlighter-rouge&quot;&gt;${10}&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;${11}&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;${12}&lt;/code&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，还有几个特殊字符用来处理参数：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数处理&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$#&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;传递到脚本的参数个数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;以一个单字符串显示所有向脚本传递的参数。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt;相同，但是使用时加引号，并在引号中返回每个参数。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$$&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;脚本运行的当前进程ID号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$!&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;后台运行的最后一个进程的ID号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$-&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;显示Shell使用的当前选项，与set命令功能相同&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$?&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt; 区别:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;相同点：都表示引用所有的位置参数;&lt;/li&gt;
  &lt;li&gt;不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-bash函数&quot;&gt;6 Bash函数&lt;/h2&gt;
&lt;h3 id=&quot;61-函数的定义&quot;&gt;6.1 函数的定义&lt;/h3&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;func_name&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
	&lt;span class=&quot;c&quot;&gt;# 函数体 &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;关键字function是可选的;&lt;/li&gt;
  &lt;li&gt;函数定义必须在第一次调用前完成，shell没有像 C 中的函数“声明”;&lt;/li&gt;
  &lt;li&gt;在一个函数内嵌套另一个函数也是可以的，但是不常用.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;函数的参数传递&lt;/strong&gt;  &lt;br /&gt;
函数以位置来引用传递过来的参数(就好像他们是位置参数一样), 例如&lt;code class=&quot;highlighter-rouge&quot;&gt;$1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;$2&lt;/code&gt;, …&lt;br /&gt;
&lt;strong&gt;函数的调用&lt;/strong&gt;&lt;br /&gt;
函数被调用或被触发, 只需要简单地用函数名来调用，有参数的话将参数依次置于函数名之后。&lt;/p&gt;
&lt;h3 id=&quot;62-无参函数的调用&quot;&gt;6.2 无参函数的调用&lt;/h3&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;func1&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
	&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt; 
	&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;This is func1&quot;&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 

&lt;span class=&quot;c&quot;&gt;# Calling func1 &lt;/span&gt;
func1 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hello World! 
This is func1 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;63-有参函数的调用&quot;&gt;6.3 有参函数的调用&lt;/h3&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;func2&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
	&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;This is func2&quot;&lt;/span&gt; 

	&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt; 
	&lt;span class=&quot;nv&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt; 
	&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;a is : &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$a&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 
	&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;b is : &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$b&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 

&lt;span class=&quot;c&quot;&gt;# Calling func2,and pass two parameters &lt;/span&gt;
func2 &lt;span class=&quot;s2&quot;&gt;&quot;aaa&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;bbb&quot;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This is func2 
a is : aaa 
b is : bbb 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;64-函数中参数的作用域&quot;&gt;6.4 函数中参数的作用域&lt;/h3&gt;
&lt;p&gt;在函数调用之前，所有在函数内声明且没有明确声明为 local 的变量都可在函数体外可见（默认为全局变量）。&lt;br /&gt;
如果变量用local 来声明,那么它只能在该变量声明的代码块中可见。这个代码块就是局部”范围”。在一个函数内,局部变量意味着只能在函数代码块内它才有意义。&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash &lt;/span&gt;
 
func&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;nv&quot;&gt;global_var&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;I am global_var difined in function func.&quot;&lt;/span&gt; 
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$global_var&lt;/span&gt; 

    &lt;span class=&quot;nb&quot;&gt;local &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;loc_var&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;I am local_var defined in function func&quot;&lt;/span&gt; 
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$loc_var&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
 
func 
&lt;span class=&quot;nb&quot;&gt;echo 
echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$global_var&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$loc_var&lt;/span&gt; 

&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I am global_var difined &lt;span class=&quot;k&quot;&gt;in function &lt;/span&gt;func. 
I am local_var defined &lt;span class=&quot;k&quot;&gt;in function &lt;/span&gt;func 

I am global_var difined &lt;span class=&quot;k&quot;&gt;in function &lt;/span&gt;func. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;7-bash数组&quot;&gt;7 Bash数组&lt;/h2&gt;
&lt;p&gt;Bash 只支持一维数组，用圆括号()来表示，数组元素之间用”空格”符号来分割（不同于C、C++、Java等语言中用逗号分割）。&lt;/p&gt;
&lt;h3 id=&quot;71-数组的定义与初始化&quot;&gt;7.1 数组的定义与初始化&lt;/h3&gt;
&lt;p&gt;初始化时不需要指定数组的大小。和其它大部分语言一样，bash数组元素的下标从0开始。&lt;br /&gt;
初始化方式1：直接初始化&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;arr_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;value1 value2 ... valueN&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;初始化方式2: 用下标初始化&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;arr_name[0]&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;value1 
arr_name[1]&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;value2 
arr_name[223]&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;value3 &lt;span class=&quot;c&quot;&gt;# 不连续初始化 &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;数组成员不必一定要连续，空缺元素是允许的;&lt;/li&gt;
  &lt;li&gt;数组的一部分成员允许不被初始化, 没有被初始化的元素将打印空(NULL)值;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;72-访问数组元素&quot;&gt;7.2 访问数组元素&lt;/h3&gt;
&lt;p&gt;访问数组元素的一般格式：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;arr_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[index]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;遍历数组&lt;br /&gt;
使用* 或@ 可以获取数组中的所有元素&lt;br /&gt;
实例：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;my_arr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;A B C &lt;span class=&quot;s2&quot;&gt;&quot;ddd&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 

&lt;span class=&quot;c&quot;&gt;# 遍历数组格式1 &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;my_arr: &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;my_arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[*]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; 

# 遍历数组格式2 
echo &quot;&lt;/span&gt;my_arr: &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;my_arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[@]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;my_arr: A B C ddd 
my_arr: A B C ddd 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;73-获取数组长度&quot;&gt;7.3 获取数组长度&lt;/h3&gt;
&lt;p&gt;获取数组长度（即数组中的元素个数），和遍历数组语法很相似，只是在数组名前加了#符号，格式：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;${#&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;arr_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[*]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;${#&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;my_arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[@]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 获取数组my_arr的长度（元素个数） &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;my_arr length: &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${#&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;my_arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[*]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;

 # 获取数组my_arr的长度, 
echo &quot;&lt;/span&gt;my_arr length: &lt;span class=&quot;k&quot;&gt;${#&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;my_arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[@]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;my_arr length: 4 
my_arr length: 4 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;8-bash字符串操作&quot;&gt;8 Bash字符串操作&lt;/h2&gt;
&lt;p&gt;在Bash中，字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别如前文所述。&lt;br /&gt;
定义字符串实例：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;str1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;hello 
&lt;span class=&quot;nv&quot;&gt;str2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'hello'&lt;/span&gt; 
&lt;span class=&quot;nv&quot;&gt;str3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello&quot;&lt;/span&gt; 

&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str1&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str2&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str3&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello 
hello 
hello 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;81-获取字符串长度&quot;&gt;8.1 获取字符串长度&lt;/h3&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;${#&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;string_name&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;my_str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello world&quot;&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;my_str length: &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${#&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;my_str&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; 
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;my_str length: 11 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;82-字符串拼接&quot;&gt;8.2 字符串拼接&lt;/h3&gt;
&lt;p&gt;和Java Python等语言类似，bash允许直接将字符串拼接在一起以获得新的字符串。&lt;br /&gt;
实例：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;str1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello&quot;&lt;/span&gt; 
&lt;span class=&quot;nv&quot;&gt;str2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;world&quot;&lt;/span&gt; 

&lt;span class=&quot;nv&quot;&gt;str3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str1&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str2&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str3&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello world 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;83-提取子串&quot;&gt;8.3 提取子串&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;表达式&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;${string:position}&lt;/td&gt;
      &lt;td&gt;在string中, 从位置position开始提取子串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${string:position:length}&lt;/td&gt;
      &lt;td&gt;在string中, 从位置position开始提取长度为length的子串&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;实例1：从位置1开始提取子串&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello world&quot;&lt;/span&gt; 

&lt;span class=&quot;nv&quot;&gt;sub_str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;:1&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;sub_str: &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;sub_str&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub_str: ello world 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;实例2：从位置1开始提取长度为3的子串&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello world&quot;&lt;/span&gt; 
&lt;span class=&quot;nv&quot;&gt;sub_str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;:1:3&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; 

&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;sub_str: &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;sub_str&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub_str: ell 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;84-删除子串&quot;&gt;8.4 删除子串&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;表达式&lt;/td&gt;
      &lt;td&gt;含义&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${string#substring}&lt;/td&gt;
      &lt;td&gt;从string的开头, 删除最短匹配substring的子串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${string##substring}&lt;/td&gt;
      &lt;td&gt;从string的开头, 删除最长匹配substring的子串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${string%substring}&lt;/td&gt;
      &lt;td&gt;从string的结尾, 删除最短匹配substring的子串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${string%%substring}&lt;/td&gt;
      &lt;td&gt;从string的结尾, 删除最长匹配substring的子串&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;记忆：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;#表示从头匹配，%表示从尾匹配&lt;/li&gt;
  &lt;li&gt;一个符号（#或者%）表示最短匹配，两个符号（##或者%%）表示最长匹配&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：substring可以是正则表达式。&lt;br /&gt;
实例：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;abcabcdefabcabc&quot;&lt;/span&gt; 

&lt;span class=&quot;c&quot;&gt;# 从str的开头,删除最短匹配的以a开头c结尾的子串 &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 将删除最左端的abc &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 输出：abcdefabcabc &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;#a*c&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 

&lt;span class=&quot;c&quot;&gt;# 从str的开头,删除最长匹配以a开头b结尾的子串 &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 将删除abcabcdefabcab &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 输出：c &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;##a*b&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 

&lt;span class=&quot;c&quot;&gt;# 从str的结尾,删除最短匹配以a开头c结尾的子串 &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 将删除最右端的abc &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 输出：abcabcdefabc &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%a*c&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 

&lt;span class=&quot;c&quot;&gt;# 从str的结尾,删除最长匹配以a开头c结尾的子串 &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 将删除整个字符串 &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 输出：空 &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%%a*b&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;85-替换子串&quot;&gt;8.5 替换子串&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;表达式&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;${string/substring/replacement}&lt;/td&gt;
      &lt;td&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;$replacement&lt;/code&gt; 来代替第一个匹配的&lt;code class=&quot;highlighter-rouge&quot;&gt;$substring&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${string//substring/replacement}&lt;/td&gt;
      &lt;td&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;$replacement&lt;/code&gt; 代替所有匹配的&lt;code class=&quot;highlighter-rouge&quot;&gt;$substring&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${string/#substring/replacement}&lt;/td&gt;
      &lt;td&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;$string&lt;/code&gt;的前缀匹配&lt;code class=&quot;highlighter-rouge&quot;&gt;$substring&lt;/code&gt;, 那么就用&lt;code class=&quot;highlighter-rouge&quot;&gt;$replacement&lt;/code&gt;来代替匹配到的&lt;code class=&quot;highlighter-rouge&quot;&gt;$substring&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;${string/%substring/replacement}&lt;/td&gt;
      &lt;td&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;$string&lt;/code&gt;的后缀匹配&lt;code class=&quot;highlighter-rouge&quot;&gt;$substring&lt;/code&gt;, 那么就用&lt;code class=&quot;highlighter-rouge&quot;&gt;$replacement&lt;/code&gt;来代替匹配到的&lt;code class=&quot;highlighter-rouge&quot;&gt;$substring&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;实例：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;abcdefabc&quot;&lt;/span&gt; 

&lt;span class=&quot;c&quot;&gt;# 用hello替换第一个abc&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 输出：hellodefabc &lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 用hello替换第一个abc &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 输出：hellodefhello &lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 前缀匹配替换 &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/#&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;world&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 输出：worlddefabc &lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 后缀匹配替换 &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/％&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;world&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 输出：abcdefworld &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;9-彩色文本&quot;&gt;9 彩色文本&lt;/h2&gt;
&lt;p&gt;格式: echo -e “\033[字背景颜色;字体颜色m字符串\033[0m”&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;33[41;36m something here &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;33[0m&quot;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中41的位置代表底色, 36的位置是代表字的颜色&lt;/p&gt;

&lt;p&gt;那些ascii code 是对颜色调用的始末.&lt;br /&gt;
\033[ ; m …… \033[0m&lt;/p&gt;

&lt;p&gt;字背景颜色范围:40———49&lt;br /&gt;
40:   $\color{#000000}{黑色}$ &lt;br /&gt;
41:   $\color{#880000}{深红}$ &lt;br /&gt;
42:   $\color{#00ff00}{绿色}$  &lt;br /&gt;
43:   $\color{#dddd00}{黄色}$ &lt;br /&gt;
44:   $\color{#0000ff}{蓝色}$ &lt;br /&gt;
45:   $\color{#ff00ff}{紫色}$ &lt;br /&gt;
46:   $\color{#007700}{深绿}$ &lt;br /&gt;
47:   $\color{#bbbbbb}{白色}$&lt;/p&gt;

&lt;p&gt;字颜色:30———39 &lt;br /&gt;
30:   $\color{#000000}{黑色}$&lt;br /&gt;
31:   $\color{#ff0000}{红色}$ &lt;br /&gt;
32:   $\color{#00ff00}{绿色}$ &lt;br /&gt;
33:   $\color{#dddd00}{黄色}$ &lt;br /&gt;
34:   $\color{#0000ff}{蓝色}$ &lt;br /&gt;
35:   $\color{#ff00ff}{紫色}$ &lt;br /&gt;
36:   $\color{#008800}{深绿}$ &lt;br /&gt;
37:   $\color{#bbbbbb}{白色}$&lt;/p&gt;

&lt;p&gt;======ANSI控制码的说明=========================================&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[0m&lt;/td&gt;
      &lt;td&gt;关闭所有属性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[1m&lt;/td&gt;
      &lt;td&gt;设置高亮度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[4m&lt;/td&gt;
      &lt;td&gt;下划线&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[5m&lt;/td&gt;
      &lt;td&gt;闪烁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[7m&lt;/td&gt;
      &lt;td&gt;反显&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[8m&lt;/td&gt;
      &lt;td&gt;消隐&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[30m – \33[37m&lt;/td&gt;
      &lt;td&gt;设置前景色&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[40m – \33[47m&lt;/td&gt;
      &lt;td&gt;设置背景色&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[nA&lt;/td&gt;
      &lt;td&gt;光标上移n行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[nB&lt;/td&gt;
      &lt;td&gt;光标下移n行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[nC&lt;/td&gt;
      &lt;td&gt;光标右移n行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[nD&lt;/td&gt;
      &lt;td&gt;光标左移n行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[y;xH&lt;/td&gt;
      &lt;td&gt;设置光标位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[2J&lt;/td&gt;
      &lt;td&gt;清屏&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[K&lt;/td&gt;
      &lt;td&gt;清除从光标到行尾的内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[s&lt;/td&gt;
      &lt;td&gt;保存光标位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[u&lt;/td&gt;
      &lt;td&gt;恢复光标位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[?25l&lt;/td&gt;
      &lt;td&gt;隐藏光标&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[?25h&lt;/td&gt;
      &lt;td&gt;显示光标&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 03 Dec 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/12/03/bash-shell.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/12/03/bash-shell.html</guid>
        
        <category>shell</category>
        
        <category>program</category>
        
        
      </item>
    
      <item>
        <title>Makefile教程</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;现在讲述如何写makefile的文章比较少，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat Linux 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。
在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;01-关于程序的编译和链接&quot;&gt;0.1 关于程序的编译和链接&lt;/h2&gt;

&lt;p&gt;在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。&lt;/p&gt;

&lt;p&gt;编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。&lt;/p&gt;

&lt;p&gt;链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。&lt;/p&gt;

&lt;p&gt;总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的ObjectFile.&lt;/p&gt;

&lt;p&gt;好，言归正传，GNU的make有许多的内容，闲言少叙，还是让我们开始吧。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;1-makefile-介绍&quot;&gt;1 Makefile 介绍&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。&lt;/p&gt;

&lt;p&gt;首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。&lt;/li&gt;
  &lt;li&gt;如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。&lt;/li&gt;
  &lt;li&gt;如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1 Makefile的规则&lt;/strong&gt;&lt;br /&gt;
  在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;target... &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;prerequisites ...&lt;/span&gt;
          &lt;span class=&quot;err&quot;&gt;command&lt;/span&gt;
          &lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;
          &lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;
          &lt;span class=&quot;err&quot;&gt;---------------------------------------------------------&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。&lt;br /&gt;
prerequisites就是，要生成那个target所需要的文件或是目标。&lt;br /&gt;
command也就是make需要执行的命令。（任意的Shell命令）&lt;/p&gt;

&lt;p&gt;这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。
说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）&lt;/p&gt;

&lt;p&gt;【注】：在看别人写的Makefile文件时，你可能会碰到以下三个变量：&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;$^&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt;&lt;/code&gt;，他们三个是十分重要的三个变量，所代表的含义分别是：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;–目标文件，&lt;code class=&quot;highlighter-rouge&quot;&gt;$^&lt;/code&gt;–所有的依赖文件，&lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt;&lt;/code&gt;–第一个依赖文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2 一个示例&lt;/strong&gt;&lt;br /&gt;
正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;edit &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main.o kbd.o command.o display.o &lt;/span&gt;\
&lt;span class=&quot;nf&quot;&gt;          insert.o search.o files.o utils.o&lt;/span&gt;
           &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;main.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;kbd.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;command.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;display.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;
                      &lt;span class=&quot;err&quot;&gt;insert.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;search.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;files.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;utils.o&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;main.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main.c defs.h&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;main.c&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;kbd.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;kbd.c defs.h command.h&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;kbd.c&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;command.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;command.c defs.h command.h&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;command.c&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;display.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;display.c defs.h buffer.h&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;display.c&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;insert.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert.c defs.h buffer.h&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;insert.c&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;search.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;search.c defs.h buffer.h&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;search.c&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;files.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;files.c defs.h buffer.h command.h&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;files.c&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;utils.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;utils.c defs.h&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;utils.c&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;clean &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;main.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;kbd.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;command.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;display.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;
            &lt;span class=&quot;err&quot;&gt;insert.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;search.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;files.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;utils.o&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;反斜杠（\）是换行符的意思。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下“make clean”就可以了。&lt;/p&gt;

&lt;p&gt;在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。&lt;/p&gt;

&lt;p&gt;在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。&lt;/p&gt;

&lt;p&gt;这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.3 make是如何工作的&lt;/strong&gt;&lt;br /&gt;
在默认的方式下，也就是我们只输入make命令。那么，make会在当前目录下找名字叫“Makefile”或“makefile”的文件。如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）
当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件声明make的终极任务，也就是执行文件edit了。&lt;br /&gt;
这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。&lt;br /&gt;
通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译。&lt;/p&gt;

&lt;p&gt;于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。
而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.4 makefile中使用变量&lt;/strong&gt;&lt;br /&gt;
在上面的例子中，先让我们看看edit的规则：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;edit &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main.o kbd.o command.o display.o &lt;/span&gt;\
&lt;span class=&quot;nf&quot;&gt;      insert.o search.o files.o utils.o&lt;/span&gt;

      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;main.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;kbd.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;command.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;display.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;
            &lt;span class=&quot;err&quot;&gt;insert.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;search.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;files.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;utils.o&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏可能会更好。
比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; main.o kbd.o command.o display.o &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
      insert.o search.o files.o utils.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;于是，我们就可以很方便地在我们的makefile中以“$(objects)”的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; main.o kbd.o command.o display.o &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;            
      &lt;span class=&quot;err&quot;&gt;insert.osearch.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;files.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;utils.o&lt;/span&gt;    

&lt;span class=&quot;nl&quot;&gt;edit &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(objects)          &lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(objects)&lt;/span&gt;   
&lt;span class=&quot;nl&quot;&gt;main.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main.c defs.h           &lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;main.c&lt;/span&gt;   
&lt;span class=&quot;nl&quot;&gt;kbd.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;kbd.c defs.h command.h           &lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;kbd.c&lt;/span&gt;   
&lt;span class=&quot;nl&quot;&gt;command.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;command.c defs.h command.h          &lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;command.c&lt;/span&gt;   
&lt;span class=&quot;nl&quot;&gt;display.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;display.c defs.h buffer.h          &lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;display.c&lt;/span&gt;   
&lt;span class=&quot;nl&quot;&gt;insert.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert.c defs.h buffer.h           &lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;insert.c&lt;/span&gt;   
&lt;span class=&quot;nl&quot;&gt;search.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;search.c defs.h buffer.h           &lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;search.c&lt;/span&gt;   
&lt;span class=&quot;nl&quot;&gt;files.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;files.c defs.h buffer.h command.h           &lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;files.c&lt;/span&gt;   
&lt;span class=&quot;nl&quot;&gt;utils.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;utils.c defs.h          &lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;utils.c&lt;/span&gt;   
      
&lt;span class=&quot;nl&quot;&gt;clean &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;           
      &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(objects)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。关于变量更多的话题，我会在后续给你一一道来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.5 让make自动推导&lt;/strong&gt;&lt;br /&gt;
GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; main.o kbd.o command.o display.o &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;           
      &lt;span class=&quot;err&quot;&gt;insert.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;search.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;files.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;utils.o&lt;/span&gt;   

&lt;span class=&quot;nl&quot;&gt;edit &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(objects)           &lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(objects)&lt;/span&gt;   
&lt;span class=&quot;nl&quot;&gt;main.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h   &lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;kbd.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h command.h   &lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;command.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h command.h   &lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;display.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h buffer.h   &lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;insert.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h buffer.h   &lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;search.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h buffer.h   &lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;files.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h buffer.h command.h   &lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;utils.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h  &lt;/span&gt;
 
&lt;span class=&quot;nl&quot;&gt;.PHONY &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clean   &lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;clean &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; 
      &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(objects)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。&lt;br /&gt;
关于更为详细的“隐晦规则”和“伪目标文件”，我会在后续给你一一道来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.6 另类风格的makefile&lt;/strong&gt;&lt;br /&gt;
即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; main.o kbd.o command.o display.o &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;           
      &lt;span class=&quot;err&quot;&gt;insert.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;search.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;files.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;utils.o&lt;/span&gt; 
  
&lt;span class=&quot;nl&quot;&gt;edit &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(objects)           &lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(objects)&lt;/span&gt;   

&lt;span class=&quot;nl&quot;&gt;$(objects) &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h   &lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;kbd.o command.o files.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;command.h   &lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;display.o insert.o search.o files.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;buffer.h   &lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;.PHONY &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clean   &lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;clean &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;           
      &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(objects)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.7 清空目标文件的规则&lt;/strong&gt;&lt;br /&gt;
每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;clean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(objects)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;更为稳健的做法是：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;.PHONY &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clean&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;clean &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;-rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(objects)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。&lt;/p&gt;

&lt;p&gt;上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;2-makefile-总述&quot;&gt;2 Makefile 总述&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2.1 Makefile里有什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;显式规则&lt;/em&gt;&lt;/strong&gt;   显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;隐晦规则&lt;/em&gt;&lt;/strong&gt;   由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;变量定义&lt;/em&gt;&lt;/strong&gt;   在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;文件指示&lt;/em&gt;&lt;/strong&gt;   其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;注释&lt;/em&gt;&lt;/strong&gt;     Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“\#”。&lt;br /&gt;
最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2Makefile的文件名&lt;/strong&gt;&lt;br /&gt;
默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。&lt;br /&gt;
当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“-f”和“–file”参数，如：make -f Make.Linux或make –file Make.AIX。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3 引用其它的Makefile&lt;/strong&gt;&lt;br /&gt;
在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。&lt;br /&gt;
include的语法是：&lt;em&gt;include filename&lt;/em&gt;&lt;br /&gt;
filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）&lt;br /&gt;
在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：&lt;br /&gt;
     &lt;em&gt;include foo.make *.mk $(bar)&lt;/em&gt; &lt;br /&gt;
等价于：&lt;br /&gt;
    &lt;em&gt;include foo.make a.mk b.mk c.mk e.mk f.mk&lt;/em&gt; &lt;br /&gt;
make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;如果make执行时，有“-I”或“–include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。&lt;/li&gt;
  &lt;li&gt;如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：&lt;br /&gt;
  &lt;em&gt;-include&lt;/em&gt;&lt;br /&gt;
其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.4 环境变量 MAKEFILES&lt;/strong&gt;&lt;br /&gt;
如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。&lt;br /&gt;
但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.5 make的工作方式&lt;/strong&gt;&lt;br /&gt;
GNU的make工作时的执行步骤入下：（想来其它的make也是类似）&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;读入所有的Makefile。&lt;/li&gt;
  &lt;li&gt;读入被include的其它Makefile。&lt;/li&gt;
  &lt;li&gt;初始化文件中的变量。&lt;/li&gt;
  &lt;li&gt;推导隐晦规则，并分析所有规则。&lt;/li&gt;
  &lt;li&gt;为所有的目标文件创建依赖关系链。&lt;/li&gt;
  &lt;li&gt;根据依赖关系，决定哪些目标要重新生成。&lt;/li&gt;
  &lt;li&gt;执行生成命令。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。&lt;br /&gt;
当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;3-makefile书写规则&quot;&gt;3 Makefile书写规则&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;规则包含两个部分，一个是依赖关系，一个是生成目标的方法。&lt;br /&gt;
在Makefile中，规则的顺序是很重要的，因为，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。 &lt;br /&gt;
好了，还是让我们来看一看如何书写规则。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1 规则举例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;foo.o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo.c defs.h       &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; foo模块&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-g&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;foo.c&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令“cc -c -g foo.c”（以Tab键开头）。这个规则告诉我们两件事：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。&lt;/li&gt;
  &lt;li&gt;如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;3.2 规则的语法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;targets &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;prerequisites&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;command&lt;/span&gt;
         &lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;或是这样：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;targets &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;prerequisites ; command&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;command&lt;/span&gt;
         &lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。&lt;br /&gt;
command是命令行，如果其不与“target:prerequisites”在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）&lt;br /&gt;
prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。&lt;br /&gt;
如果命令太长，你可以使用反斜框（‘\’）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何成成目标文件。
一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3 在规则中使用通配符&lt;/strong&gt;
如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三各通配符：“*”，“?”和“[…]”。这是和Unix的B-Shell是相同的。   &lt;br /&gt;
&lt;strong&gt;&lt;em&gt;”~“&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
波浪号（“~”）字符在文件名中也有比较特殊的用途。如果是“~/test”，这就表示当前用户的$HOME目录下的test目录。而“~hchen/test”则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;”*“&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
通配符代替了你一系列的文件，如“*.c”表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：“*”，那么可以用转义字符“\”，如“\*”来表示真实的“*”字符，而不是任意长度的字符串。
好吧，还是先来看几个例子吧：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;clean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*.o&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;*.c&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;lpr&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$?&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;touch&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;print&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的[.c]文件。其中的“$?”是一个自动化变量，我会在后面给你讲述。&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面这个例子，表示了，通符同样可以用在变量中。并不是说[*.o]会展开，不！objects的值就是“*.o”。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;wildcard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.o&lt;span class=&quot;nf&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这种用法由关键字“wildcard”指出，关于Makefile的关键字，我们将在后面讨论。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.4 文件搜寻&lt;/strong&gt;&lt;br /&gt;
在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。
Makefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;VPATH&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; src:../headers
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）
另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;vpath &amp;lt; pattern&amp;gt; &amp;lt; directories&amp;gt; 为符合模式&amp;lt; pattern&amp;gt;的文件指定搜索目录。&lt;/li&gt;
  &lt;li&gt;vpath &amp;lt; pattern&amp;gt; 清除符合模式&amp;lt; pattern&amp;gt;的文件的搜索目录。&lt;/li&gt;
  &lt;li&gt;vpath 清除所有已被设置好了的文件搜索目录。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;vapth使用方法中的&amp;lt; pattern&amp;gt;需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。&amp;lt; pattern&amp;gt;指定了要搜索的文件集，而&amp;lt; directories&amp;gt;则指定了的文件集的搜索的目录。例如：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;vpath&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;%.h&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;../headers&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该语句表示，要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话）
我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的&amp;lt; pattern&amp;gt;，或是被重复了的&amp;lt; pattern&amp;gt;，那么，make会按照vpath语句的先后顺序来执行搜索。如：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;vpath&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;%.c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;foo&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;vpath&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;%.c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;blish&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;vpath&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;%.c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;bar&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;vpath&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;%.c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;foo;bar&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;vpath&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;%.c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;blish&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.5 伪目标&lt;/strong&gt;&lt;br /&gt;
最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”，&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;clean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;temp&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;正像我们前面例子中的“clean”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标）&lt;br /&gt;
因为，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。&lt;br /&gt;
当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;.PHONY &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clean&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;.PHONY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clean&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;clean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;temp&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;all &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;prog1 prog2 prog3&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.PHONY &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;all&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;prog1 &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;prog1.o utils.o&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;prog1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;prog1.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;utils.o&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;prog2 &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;prog2.o&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;prog2&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;prog2.o&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;prog3 &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;prog3.o sort.o utils.o&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;prog3&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;prog3.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;sort.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;utils.o&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。&lt;/p&gt;

&lt;p&gt;随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;.PHONY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cleanall cleanobj cleandiff&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;cleanall &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cleanobj cleandiff&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;program&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;cleanobj &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*.o&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;cleandiff &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*.diff&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;“makeclean”将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“makecleanall”和“make cleanobj”和“makecleandiff”命令来达到清除不同种类文件的目的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.6 多目标&lt;/strong&gt;&lt;br /&gt;
Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;bigoutput littleoutput &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;text.g&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;generate&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;text.g&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-$(subst&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;output,,$@)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$@&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上述规则等价于：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;bigoutput &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;text.g&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;generate&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;text.g&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-big&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;bigoutput&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;littleoutput &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;text.g&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;generate&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;text.g&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-little&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;littleoutput&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;-$(subst output,,$@)&lt;/code&gt;中的“&lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt;”表示执行一个Makefile的函数，函数名为&lt;code class=&quot;highlighter-rouge&quot;&gt;subst&lt;/code&gt;，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，“&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;”表示目标的集合，就像一个数组，“&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;”依次取出目标，并执于命令。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.7 静态模式&lt;/strong&gt; &lt;br /&gt;
静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。&lt;br /&gt;
target-parrtern是指明了targets的模式，也就是的目标集模式。&lt;br /&gt;
prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。&lt;br /&gt;
这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的定义成“%.o”，意思是我们的集合中都是以“.o”结尾的，而如果我们的定义成“%.c”，意思是对所形成的目标集进行二次定义，其计算方法是，取模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。
所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠“\”进行转义，来标明真实的“%”字符。&lt;br /&gt;
看一个例子：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; foo.o bar.o
&lt;span class=&quot;nl&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(objects)&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;$(objects)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;%.o: %.c&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;$(CC)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(CFLAGS)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$@&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面的例子中，指明了我们的目标从&lt;code class=&quot;highlighter-rouge&quot;&gt;$(object)&lt;/code&gt;中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量&lt;code class=&quot;highlighter-rouge&quot;&gt;$object&lt;/code&gt;集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foobar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.c bar.c”。而命令中的“&lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt;&lt;/code&gt;”和“&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;”则是自动化变量，“&lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt;&lt;/code&gt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;”表示目标集（也就是”foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;foo.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo.c&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;$(CC)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(CFLAGS)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;foo.c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;foo.o&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;bar.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bar.c&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;$(CC)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(CFLAGS)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;bar.c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;bar.o&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;files&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; foo.elc bar.o lose.o

&lt;span class=&quot;nl&quot;&gt;$(filter %.o,$(files))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;%.o: %.c&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;$(CC)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(CFLAGS)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$@&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;$(filter %.elc,$(files))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;%.elc: %.el&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;emacs&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;batch-byte-compile&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&amp;lt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$(filter %.o,$(files))&lt;/code&gt;表示调用Makefile的filter函数，过滤“&lt;code class=&quot;highlighter-rouge&quot;&gt;$filter&lt;/code&gt;”集，只要其中模式为“%.o”的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.8 自动生成依赖性&lt;/strong&gt;&lt;br /&gt;
在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句“#include “defs.h””，那么我们的依赖关系应该是：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;main.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main.c defs.h&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-M&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;main.c&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其输出是：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;main.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main.c defs.h&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc -M main.c&lt;/code&gt;的输出是：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;main.o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main.c defs.h /usr/include/stdio.h /usr/include/features.h &lt;/span&gt;\
&lt;span class=&quot;nf&quot;&gt;      /usr/include/sys/cdefs.h /usr/include/gnu/stubs.h &lt;/span&gt;\
&lt;span class=&quot;nf&quot;&gt;      /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h &lt;/span&gt;\
&lt;span class=&quot;nf&quot;&gt;      /usr/include/bits/types.h /usr/include/bits/pthreadtypes.h &lt;/span&gt;\
&lt;span class=&quot;nf&quot;&gt;      /usr/include/bits/sched.h /usr/include/libio.h &lt;/span&gt;\
&lt;span class=&quot;nf&quot;&gt;      /usr/include/_G_config.h /usr/include/wchar.h &lt;/span&gt;\
&lt;span class=&quot;nf&quot;&gt;      /usr/include/bits/wchar.h /usr/include/gconv.h &lt;/span&gt;\
&lt;span class=&quot;nf&quot;&gt;      /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h &lt;/span&gt;\
&lt;span class=&quot;nf&quot;&gt;      /usr/include/bits/stdio_lim.h&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc -MM main.c&lt;/code&gt;的输出则是：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;main.o: main.c defs.h&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让Makefile自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。&lt;br /&gt;
于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。&lt;br /&gt;
这里，我们给出了一个模式规则来产生[.d]文件：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;%.d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;%.c&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;@set&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-e;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$@;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;gcc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-MM&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$@.$$$$;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;
      &lt;span class=&quot;nl&quot;&gt;sed 's,\($*\)\.o[ &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;]*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;\1&lt;span class=&quot;nf&quot;&gt;.o $@ : &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;g' &amp;lt; $@.$$$$ &amp;gt; $@; &lt;/span&gt;\
&lt;span class=&quot;nf&quot;&gt;      rm -f $@.$$$$&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“&lt;code class=&quot;highlighter-rouge&quot;&gt;rm-f $@&lt;/code&gt;”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“&lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt;&lt;/code&gt;”，也就是[.c]文件生成依赖文件，“&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;”表示模式“%.d”文件，如果有一个C文件是name.c，那么“%”就是“name”，&lt;code class=&quot;highlighter-rouge&quot;&gt;$$$$&lt;/code&gt;为字符串”&lt;code class=&quot;highlighter-rouge&quot;&gt;$$&lt;/code&gt;“意为进程号，一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档，&lt;code class=&quot;highlighter-rouge&quot;&gt;($*)&lt;/code&gt;为第一个分组依赖去掉后缀，依次取出所有依赖分组，重组后赋给$@。第四行就是删除临时文件。
总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;main.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main.c defs.h&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;转成：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;main.o main.d &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main.c defs.h&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;sources&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; foo.c bar.c
&lt;span class=&quot;k&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;sx&quot;&gt; $(sources:.c=.d)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上述语句中的“&lt;code class=&quot;highlighter-rouge&quot;&gt;$(sources:.c=.d)&lt;/code&gt;”中的“.c=.d”的意思是做一个替换，把变量&lt;code class=&quot;highlighter-rouge&quot;&gt;$(sources)&lt;/code&gt;所有[.c]的字串都替换成[.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;4-makefile-书写命令&quot;&gt;4 Makefile 书写命令&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。&lt;br /&gt;
我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被“/bin/sh”——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，“#”是注释符，很像C/C++中的“//”，其后的本行字符都被注释。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.1 显示命令&lt;/strong&gt;&lt;br /&gt;
通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：&lt;/p&gt;

&lt;p&gt;  @echo 正在编译XXX模块……&lt;/p&gt;

&lt;p&gt;当make执行时，会输出“正在编译XXX模块……”字串，但不会输出命令，如果没有“@”，那么，make将输出：&lt;/p&gt;

&lt;p&gt;  echo 正在编译XXX模块……&lt;br /&gt;
  正在编译XXX模块……&lt;/p&gt;

&lt;p&gt;如果make执行时，带入make参数“-n”或“–just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。
而make参数“-s”或“–slient”则是全面禁止命令的显示。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.2 命令执行&lt;/strong&gt;&lt;br /&gt;
当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：&lt;br /&gt;
示例一：&lt;br /&gt;
 exec:&lt;br /&gt;
cd /home/hchen&lt;br /&gt;
pwd&lt;/p&gt;

&lt;p&gt;示例二：&lt;br /&gt;
 exec:&lt;br /&gt;
 cd /home/hchen; pwd&lt;/p&gt;

&lt;p&gt;当我们执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。&lt;br /&gt;
make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS-DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.3 命令出错&lt;/strong&gt;&lt;br /&gt;
每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。&lt;br /&gt;
有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。&lt;br /&gt;
为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;clean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;-rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*.o&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;还有一个全局的办法是，给make加上“-i”或是“–ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。&lt;br /&gt;
还有一个要提一下的make的参数的是“-k”或是“–keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.4 嵌套执行make&lt;/strong&gt;&lt;br /&gt;
在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。&lt;br /&gt;
例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;subsystem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;subdir&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(MAKE)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其等价于：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;subsystem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;$(MAKE)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-C&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;subdir&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。&lt;br /&gt;
我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。&lt;br /&gt;
如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;export&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;unexport&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如：&lt;br /&gt;
 示例一：&lt;br /&gt;
  export variable = value&lt;br /&gt;
 其等价于：&lt;br /&gt;
  variable = value&lt;br /&gt;
  export variable&lt;br /&gt;
 其等价于：&lt;br /&gt;
  export variable := value&lt;br /&gt;
 其等价于：&lt;br /&gt;
  variable := value&lt;br /&gt;
  export variable&lt;/p&gt;

&lt;p&gt; 示例二：&lt;br /&gt;
  export variable += value&lt;br /&gt;
 其等价于：&lt;br /&gt;
  variable += value&lt;br /&gt;
  export variable&lt;/p&gt;

&lt;p&gt; 如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。&lt;br /&gt;
 需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。&lt;br /&gt;
但是make命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;subsystem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;subdir&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(MAKE)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;MAKEFLAGS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。&lt;br /&gt;
还有一个在“嵌套执行”中比较有用的参数，“-w”或是“–print-directory”会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Entering directory `/home/hchen/gnu/make'.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;而在完成下层make后离开目录时，我们会看到：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Leaving directory `/home/hchen/gnu/make'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当你使用“-C”参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有“-s”（“–slient”）或是“–no-print-directory”，那么，“-w”总是失效的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.5 定义命令包&lt;/strong&gt;&lt;br /&gt;
如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;run-yacc&lt;/span&gt;
   &lt;span class=&quot;err&quot;&gt;yacc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(firstword&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$^)&lt;/span&gt;
   &lt;span class=&quot;err&quot;&gt;mv&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;y.tab.c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$@&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;endef&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;foo.c &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo.y&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;$(run-yacc)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的“&lt;code class=&quot;highlighter-rouge&quot;&gt;$^&lt;/code&gt;”就是“foo.y”，“&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;”就是“foo.c”（有关这种以“$”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用变量————
在 Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是 Makefile的其它部分中。变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。有一些变量是很奇怪字串，如“\$&amp;lt;”、“\$@”等，这些是自动化变量，我会在后面介绍。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;一、变量的基础&lt;/strong&gt;&lt;br /&gt;
变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“&lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt;”符号，但最好用小括号“()”或是大括号“{}”把变量给包括起来。如果你要使用真实的“&lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt;”字符，那么你需要用“&lt;code class=&quot;highlighter-rouge&quot;&gt;$$&lt;/code&gt;”来表示。变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。&lt;/p&gt;

&lt;p&gt;先看一个例子：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; program.o foo.o utils.o
&lt;span class=&quot;nl&quot;&gt;program &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(objects)&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;program&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(objects)&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;$(objects) &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defs.h&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; c
&lt;span class=&quot;nl&quot;&gt;prog.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;prog.$(foo)&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;$(foo)$(foo)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-$(foo)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;prog.$(foo)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;展开后得到：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;prog.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;prog.c&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;cc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;prog.c&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、变量中的变量&lt;/strong&gt;&lt;br /&gt;
在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。
先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(bar)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(ugh)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;ugh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Huh?

&lt;span class=&quot;nl&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(foo)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们执行“make all”将会打出变量&lt;code class=&quot;highlighter-rouge&quot;&gt;$(foo)&lt;/code&gt;的值是“Huh?”（ &lt;code class=&quot;highlighter-rouge&quot;&gt;$(foo)&lt;/code&gt;的值是&lt;code class=&quot;highlighter-rouge&quot;&gt;$(bar)&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;$(bar)&lt;/code&gt;的值是&lt;code class=&quot;highlighter-rouge&quot;&gt;$(ugh)&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;$(ugh)&lt;/code&gt;的值是“Huh?”）可见，变量是可以使用后面的变量来定义的。
这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;CFLAGS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(include_dirs)&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-O&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;include_dirs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Ifoo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Ibar&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;CFLAGS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(CFLAGS)&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-O&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;或：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(B)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(A)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。
为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，如：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; foo
&lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(x)&lt;/span&gt; bar
&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; later
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其等价于：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; foo bar
&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; later
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(x)&lt;/span&gt; bar
&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; foo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;那么，y的值是“bar”，而不是“foo bar”。&lt;/p&gt;

&lt;p&gt;上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量“MAKELEVEL”的使用：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;ifeq&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;(0,${MAKELEVEL})&lt;/span&gt;
      &lt;span class=&quot;nv&quot;&gt;cur-dir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;shell&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;nv&quot;&gt;whoami&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;shell&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;whoami&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;nv&quot;&gt;host-type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;shell&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;arch&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;nv&quot;&gt;MAKE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;${MAKE}&lt;/span&gt; host-type&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-type&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;whoami&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;${whoami}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;endif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;关于条件表达式和函数，我们在后面再说，对于系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的“嵌套使用make”），那么，这个变量会记录了我们的当前Makefile的调用层数。&lt;/p&gt;

&lt;p&gt;下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;nullstring&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;space&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(nullstring)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# end of the line&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;nullstring 是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个 Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;dir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; /foo/bar &lt;span class=&quot;c&quot;&gt;# directory to put the frobs in&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;dir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。&lt;/p&gt;

&lt;p&gt;还有一个比较有用的操作符是“?=”，先看示例：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;FOO&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?=&lt;/span&gt; bar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;ifeq&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;($(origin FOO), undefined)&lt;/span&gt;
      &lt;span class=&quot;nv&quot;&gt;FOO&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; bar
&lt;span class=&quot;k&quot;&gt;endif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;三、变量高级用法&lt;/strong&gt;&lt;br /&gt;
这里介绍两种变量的高级使用方法，第一种是变量值的替换。
我们可以替换变量中的共有的部分，其格式是“&lt;code class=&quot;highlighter-rouge&quot;&gt;$(var:a=b)&lt;/code&gt;”或是“&lt;code class=&quot;highlighter-rouge&quot;&gt;${var:a=b}&lt;/code&gt;”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。&lt;/p&gt;

&lt;p&gt;还是看一个示例吧：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; a.o b.o c.o
&lt;span class=&quot;nv&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(foo:.o=.c)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个示例中，我们先定义了一个“&lt;code class=&quot;highlighter-rouge&quot;&gt;$(foo)&lt;/code&gt;”变量，而第二行的意思是把“&lt;code class=&quot;highlighter-rouge&quot;&gt;$(foo)&lt;/code&gt;”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“&lt;code class=&quot;highlighter-rouge&quot;&gt;$(bar)&lt;/code&gt;”的值就是“a.c b.c c.c”。
另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; a.o b.o c.o
&lt;span class=&quot;nv&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(foo:%.o=%.c)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c”。&lt;/p&gt;

&lt;p&gt;第二种高级用法是——“把变量的值再当成变量”。先看一个例子：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; y
&lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; z
&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$(x)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在这个例子中，&lt;code class=&quot;highlighter-rouge&quot;&gt;$(x)&lt;/code&gt;的值是“y”，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;$($(x))&lt;/code&gt;就是&lt;code class=&quot;highlighter-rouge&quot;&gt;$(y)&lt;/code&gt;，于是&lt;code class=&quot;highlighter-rouge&quot;&gt;$(a)&lt;/code&gt;的值就是“z”。（注意，是“x=y”，而不是“&lt;code class=&quot;highlighter-rouge&quot;&gt;x=$(y)&lt;/code&gt;”）&lt;/p&gt;

&lt;p&gt;我们还可以使用更多的层次：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; y
&lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; z
&lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; u
&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$(x)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里的$(a)的值是“u”，相关的推导留给读者自己去做吧。
让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(y)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; z
&lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Hello
&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$(x)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;$($(x))&lt;/code&gt;被替换成了&lt;code class=&quot;highlighter-rouge&quot;&gt;$($(y))&lt;/code&gt;，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;$(y)&lt;/code&gt;值是“z”，所以，最终结果是：&lt;code class=&quot;highlighter-rouge&quot;&gt;a:=$(z)&lt;/code&gt;，也就是“Hello”。
再复杂一点，我们再加上函数：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; variable1
&lt;span class=&quot;nv&quot;&gt;variable2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; Hello
&lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;subst&lt;/span&gt; 1,2,&lt;span class=&quot;nv&quot;&gt;$(x)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; y
&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$(z)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个例子中，“&lt;code class=&quot;highlighter-rouge&quot;&gt;$($($(z)))&lt;/code&gt;”扩展为“&lt;code class=&quot;highlighter-rouge&quot;&gt;$($(y))&lt;/code&gt;”，而其再次被扩展为“&lt;code class=&quot;highlighter-rouge&quot;&gt;$($(subst 1,2,$(x)))&lt;/code&gt;”。&lt;code class=&quot;highlighter-rouge&quot;&gt;$(x)&lt;/code&gt;的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成“variable2”，再取其值，所以，最终，&lt;code class=&quot;highlighter-rouge&quot;&gt;$(a)&lt;/code&gt;的值就是&lt;code class=&quot;highlighter-rouge&quot;&gt;$(variable2)&lt;/code&gt;的值—— “Hello”。（喔，好不容易）
在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;first_second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Hello
&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; first
&lt;span class=&quot;nv&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; second
&lt;span class=&quot;nv&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$a_$b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里的“&lt;code class=&quot;highlighter-rouge&quot;&gt;$a_$b&lt;/code&gt;”组成了“first_second”，于是，&lt;code class=&quot;highlighter-rouge&quot;&gt;$(all)&lt;/code&gt;的值就是“Hello”。
再来看看结合第一种技术的例子：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;a_objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; a.o b.o c.o
&lt;span class=&quot;nv&quot;&gt;1_objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; 1.o 2.o 3.o
&lt;span class=&quot;nv&quot;&gt;sources&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$(a1)&lt;/span&gt;_objects:.o&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;.c&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个例子中，如果&lt;code class=&quot;highlighter-rouge&quot;&gt;$(a1)&lt;/code&gt;的值是“a”的话，那么，$(sources)的值就是“a.c b.c c.c”；如果&lt;code class=&quot;highlighter-rouge&quot;&gt;$(a1)&lt;/code&gt;的值是“1”，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;$(sources)&lt;/code&gt;的值是“1.c 2.c 3.c”。
再来看一个这种技术和“函数”与“条件语句”一同使用的例子：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;ifdef&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;do_sort&lt;/span&gt;
      &lt;span class=&quot;nv&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sort&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
      &lt;span class=&quot;nv&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; strip
&lt;span class=&quot;k&quot;&gt;endif&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; a d b g q c
&lt;span class=&quot;nv&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$(func)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(bar)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个示例中，如果定义了“do_sort”，那么：&lt;code class=&quot;highlighter-rouge&quot;&gt;foo := $(sort a d b g q c)&lt;/code&gt;，于是$(foo)的值就是“a b c d g q”，而如果没有定义“do_sort”，那么：&lt;code class=&quot;highlighter-rouge&quot;&gt;foo := $(sort a d bg q c)&lt;/code&gt;，调用的就是strip函数。
当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;dir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; foo
&lt;span class=&quot;nv&quot;&gt;$(dir)_sources&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;wildcard&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(dir)&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.c&lt;span class=&quot;nf&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(dir)_print&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;lpr&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$($(dir)_sources)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;endef&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、追加变量值&lt;/strong&gt;&lt;br /&gt;
我们可以使用“+=”操作符给变量追加值，如：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; main.o foo.o bar.o utils.o
&lt;span class=&quot;nv&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; another.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;于是，我们的&lt;code class=&quot;highlighter-rouge&quot;&gt;$(objects)&lt;/code&gt;值变成：“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）
使用“+=”操作符，可以模拟为下面的这种例子：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; main.o foo.o bar.o utils.o
&lt;span class=&quot;nv&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(objects)&lt;/span&gt; another.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;所不同的是，用“+=”更为简洁。
如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; value
&lt;span class=&quot;nv&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; more
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; value
&lt;span class=&quot;nv&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(variable)&lt;/span&gt; more
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;但如果是这种情况：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; value
&lt;span class=&quot;nv&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; more
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、override 指示符&lt;/strong&gt;&lt;br /&gt;
如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当然，你还可以追加：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用ovveride指示符，如：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;foo&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;bar&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;endef&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;六、多行变量&lt;/strong&gt;&lt;br /&gt;
还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。
define 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。
下面的这个示例展示了define的用法：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;two-lines&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;foo&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(bar)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;endef&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;七、环境变量&lt;/strong&gt;&lt;br /&gt;
make 运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）&lt;br /&gt;
因此，如果我们在环境变量中设置了“CFLAGS”环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。&lt;br /&gt;
当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层 Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）&lt;br /&gt;
当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;八、目标变量&lt;/strong&gt;&lt;br /&gt;
前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如“$&amp;lt;”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。
当然，我样同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。&lt;br /&gt;
其语法是：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;overide&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。&lt;br /&gt;
这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;prog &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CFLAGS = -g&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;prog &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;prog.o foo.o bar.o&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;$(CC)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(CFLAGS)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;prog.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;foo.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;bar.o&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;prog.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;prog.c&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;$(CC)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(CFLAGS)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;prog.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;foo.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo.c&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;$(CC)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(CFLAGS)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;foo.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;bar.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bar.c&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;$(CC)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(CFLAGS)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;bar.c&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在这个示例中，不管全局的&lt;code class=&quot;highlighter-rouge&quot;&gt;$(CFLAGS)&lt;/code&gt;的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），&lt;code class=&quot;highlighter-rouge&quot;&gt;$(CFLAGS)&lt;/code&gt;的值都是“-g”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;九、模式变量&lt;/strong&gt;&lt;br /&gt;
在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。&lt;/p&gt;

&lt;p&gt;我们知道，make的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;%.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CFLAGS = -O&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;同样，模式变量的语法和“目标变量”一样：&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Dec 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/12/02/makefile.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/12/02/makefile.html</guid>
        
        <category>makefile</category>
        
        <category>program</category>
        
        
        <category>Debug</category>
        
      </item>
    
      <item>
        <title>Debug skill (C&amp;Make)</title>
        <description>&lt;h2 id=&quot;c语言类调试技巧&quot;&gt;C语言类调试技巧&lt;/h2&gt;
&lt;h3 id=&quot;1-使用不同的颜色打印调试信息区分调试等级&quot;&gt;1 使用不同的颜色打印调试信息,区分调试等级.&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdarg.h&amp;gt;

//仅仅是打印函数名字替换 DEBUG &amp;lt;--&amp;gt; printf
#define DEBUG(format, ...) printf(format, ##__VA_ARGS__)

//替换打印函数，在打印出来的内容加上前缀
#define XFUNC_PRINT(format, arg...) printf(&quot;XFUNC: &quot; format &quot;&quot;, ##arg)

//名字替换，并在打印出来的内容加上前缀,同时加入定位的功能。
#define TRC_P(fmt, args...) fprintf(stderr,&quot;  TRC_P(%s:%d):\t&quot; fmt, __func__, __LINE__, ##args)

//名字替换，并在打印出来的内容加上前缀,同时加入定位的功能，并让打印的前缀具备特殊颜色(\033[1;32m  \033[0m这些表示颜色，\t一定程度上使屏幕输出对齐)
#define TRC_PG(fmt, args...) fprintf(stderr, &quot;\033[1;32m  TRC_PG(%s:%d):\t\033[0m&quot; fmt, __func__, __LINE__, ## args)

//名字替换，并在打印出来的内容加上前缀,同时加入定位的功能，并让打印的前缀具备特殊颜色
#define TRC_PR(fmt, args...) fprintf(stderr, &quot;\033[1;31m  TRC_PR(%s:%d):\t\033[0m&quot; fmt, __func__, __LINE__, ## args)

int main(void)
{    
    int i= 0;    
    
    DEBUG(&quot;hello,%d\n&quot;,i++);    
    XFUNC_PRINT(&quot;hello,%d\n&quot;,i++);    
    TRC_P(&quot;hello,%d\n&quot;,i++);    
    TRC_PG(&quot;hello,%d\n&quot;,i++);    
    TRC_PR(&quot;hello,%d\n&quot;,i++);    
    
    return0;
}
    
/*
[root@localhost jz2440]# gcc test.c ;./a.out 
hello,0
XFUNC: hello,1  
TRC_P(main:27):       hello,2  
TRC_PG(main:28):      hello,3  ----这里前缀是绿色的  
TRC_PR(main:29):      hello,4  ----这里前缀是红色的
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2-以不同格式打印数据&quot;&gt;2 以不同格式打印数据.&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

//以十六进制打印一个数val的值，输出格式为val=0x...
#define HEX_PI(VAL)\
do{\
    printf(#VAL&quot;=%#x,fuc:%s,line:%d\n&quot;, VAL, __FUNCTION__, __LINE__);\
}while(0)

//以十进制打印一个数val的值，输出格式为val=...
#define DEC_PI(VAL)\
do{\
    printf(#VAL&quot;=%#d,fuc:%s,line:%d\n&quot;, VAL, __FUNCTION__, __LINE__);\
}while(0)    

void main(void){    
int i = 123;    
int j = 123;    
HEX_PI(i);    
HEX_PI(j);            

DEC_PI(i);    	
DEC_PI(j);
}

//i=0x7b,fuc:main,line:17
//j=0x7b,fuc:main,line:18
//i=123,fuc:main,line:20
//j=123,fuc:main,line:21
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3-配合宏开关在编译前静态指定打印等级&quot;&gt;3 配合宏开关在编译前静态指定打印等级&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;#if CUR_PLEVEL &amp;gt; 5
#define TRC_PR(fmt, args...) fprintf(stderr,&quot; TRC_P(%s:%d):\t&quot; fmt, __func__, __LINE__, ##args)
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;makefile调试信息输出&quot;&gt;Makefile调试信息输出&lt;/h2&gt;

&lt;h3 id=&quot;i-使用infowarningerror增加调试信息&quot;&gt;I. 使用info/warning/error增加调试信息&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;方法1: &lt;code class=&quot;highlighter-rouge&quot;&gt;$(info, &quot;here add the debug info&quot;)&lt;/code&gt;但是此不能打印出.mk的行号&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法2: &lt;code class=&quot;highlighter-rouge&quot;&gt;$(warning, &quot;here add the debug info&quot;)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法3: &lt;code class=&quot;highlighter-rouge&quot;&gt;$(error, &quot;error: this will stop the compile&quot;)&lt;/code&gt;这个可以停止当前makefile的编译&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法4: &lt;code class=&quot;highlighter-rouge&quot;&gt;$(info, $(TARGET_DEVICE))&lt;/code&gt;打印变量的值&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ii-使用echo增加调试信息echo只能在target后面的语句中使用且前面是个tab&quot;&gt;II. 使用echo增加调试信息（echo只能在target：后面的语句中使用，且前面是个TAB）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;方法1：&lt;code class=&quot;highlighter-rouge&quot;&gt; @echo &quot;start the compilexxxxxxxxxxxxxxxxxxxxxxx&quot;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法2: &lt;code class=&quot;highlighter-rouge&quot;&gt;@echo $(files)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;字体颜色控制&quot;&gt;字体颜色控制&lt;/h2&gt;
&lt;p&gt;格式: echo -e “\033[字背景颜色;字体颜色m字符串\033[0m”&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;33[41;36m something here &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;33[0m&quot;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中41的位置代表底色, 36的位置是代表字的颜色&lt;/p&gt;

&lt;p&gt;那些ascii code 是对颜色调用的始末.&lt;br /&gt;
\033[ ; m …… \033[0m&lt;/p&gt;

&lt;p&gt;字背景颜色范围:40———49&lt;br /&gt;
40:   $\color{#000000}{黑色}$ &lt;br /&gt;
41:   $\color{#880000}{深红}$ &lt;br /&gt;
42:   $\color{#00ff00}{绿色}$  &lt;br /&gt;
43:   $\color{#dddd00}{黄色}$ &lt;br /&gt;
44:   $\color{#0000ff}{蓝色}$ &lt;br /&gt;
45:   $\color{#ff00ff}{紫色}$ &lt;br /&gt;
46:   $\color{#007700}{深绿}$ &lt;br /&gt;
47:   $\color{#bbbbbb}{白色}$&lt;/p&gt;

&lt;p&gt;字颜色:30———39 &lt;br /&gt;
30:   $\color{#000000}{黑色}$&lt;br /&gt;
31:   $\color{#ff0000}{红色}$ &lt;br /&gt;
32:   $\color{#00ff00}{绿色}$ &lt;br /&gt;
33:   $\color{#dddd00}{黄色}$ &lt;br /&gt;
34:   $\color{#0000ff}{蓝色}$ &lt;br /&gt;
35:   $\color{#ff00ff}{紫色}$ &lt;br /&gt;
36:   $\color{#008800}{深绿}$ &lt;br /&gt;
37:   $\color{#bbbbbb}{白色}$&lt;/p&gt;

&lt;p&gt;======ANSI控制码的说明=========================================&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[0m&lt;/td&gt;
      &lt;td&gt;关闭所有属性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[1m&lt;/td&gt;
      &lt;td&gt;设置高亮度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[4m&lt;/td&gt;
      &lt;td&gt;下划线&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[5m&lt;/td&gt;
      &lt;td&gt;闪烁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[7m&lt;/td&gt;
      &lt;td&gt;反显&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[8m&lt;/td&gt;
      &lt;td&gt;消隐&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[30m – \33[37m&lt;/td&gt;
      &lt;td&gt;设置前景色&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[40m – \33[47m&lt;/td&gt;
      &lt;td&gt;设置背景色&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[nA&lt;/td&gt;
      &lt;td&gt;光标上移n行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[nB&lt;/td&gt;
      &lt;td&gt;光标下移n行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[nC&lt;/td&gt;
      &lt;td&gt;光标右移n行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[nD&lt;/td&gt;
      &lt;td&gt;光标左移n行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[y;xH&lt;/td&gt;
      &lt;td&gt;设置光标位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[2J&lt;/td&gt;
      &lt;td&gt;清屏&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[K&lt;/td&gt;
      &lt;td&gt;清除从光标到行尾的内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[s&lt;/td&gt;
      &lt;td&gt;保存光标位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[u&lt;/td&gt;
      &lt;td&gt;恢复光标位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[?25l&lt;/td&gt;
      &lt;td&gt;隐藏光标&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\33[?25h&lt;/td&gt;
      &lt;td&gt;显示光标&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Mon, 02 Dec 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/12/02/debug-skill.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/12/02/debug-skill.html</guid>
        
        <category>program</category>
        
        <category>makefile</category>
        
        
        <category>Debug</category>
        
      </item>
    
      <item>
        <title>MathJax Test</title>
        <description>&lt;p&gt;mathjax in markdown :)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这是一个不&lt;code class=&quot;highlighter-rouge&quot;&gt;align&lt;/code&gt;的公式&lt;/strong&gt;：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall \alpha \in A, \quad a \cdot b = 0&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;这是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;align&lt;/code&gt;的公式&lt;/strong&gt;：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\text{for OTP : $\qquad$ if }\quad E(k,\:m)=c\\
\begin{align}
k\oplus m &amp;= c \\
k &amp;= m\oplus c
\end{align}
\\
\#\{\;k \in \mathscr K : \quad E(k,\:m)=c \;\}=1 \quad \forall m,\:c %]]&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;公式块要想有较好的显示效果，必须在公式块标记符&lt;code class=&quot;highlighter-rouge&quot;&gt;$$&lt;/code&gt;&lt;strong&gt;前后&lt;/strong&gt;留有空行，否则公式将不能正常居中。行内公式无此问题。&lt;/p&gt;
</description>
        <pubDate>Sun, 30 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/30/mathjax-test.html</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/30/mathjax-test.html</guid>
        
        <category>mathjax</category>
        
        
        <category>test</category>
        
      </item>
    
      <item>
        <title>H2O theme for Jekyll</title>
        <description>&lt;p&gt;正如我在&lt;a href=&quot;http://weibo.com/1374146504/profile?topnav=1&amp;amp;wvr=6&quot;&gt;微博&lt;/a&gt;上所说的，使用&lt;a href=&quot;http://jekyll.com.cn/&quot;&gt;Jekyll&lt;/a&gt;半年以来一直没有令我满意的主题模板，所以开始计划自己写一套好看又好用的主题模板。设计之初就明确了极简主义，风格采用扁平化了，通过卡片式设计来进行区块分明的布局，参考了Medium的ui样式和知乎专栏的视觉风格。&lt;/p&gt;

&lt;h2 id=&quot;h2o&quot;&gt;H2O&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kaeyleo/jekyll-theme-H2O&quot;&gt;源码及使用文档 →&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-realhome.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;新主题名叫”H2O”，基于Jekyll 3.0.x（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;gem update jekyll&lt;/code&gt;升级Jekyll），Markdown的代码高亮不再支持pygments转而使用rouge，咱已经默认配置了 &lt;code class=&quot;highlighter-rouge&quot;&gt;highlighter: rouge&lt;/code&gt; 。用到的技术栈也很简单：引入jQuery类库，使用Sass编写样式，使用Gulp来编译Sass、合并压缩css、js，开源在&lt;a href=&quot;https://github.com/kaeyleo/jekyll-theme-H2O&quot;&gt;Github&lt;/a&gt;上，稍作配置即可用于你的Jekyll博客上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-sketchdesign.png&quot; alt=&quot;Design with Sketch&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用Sketch完成H2O主题的原型设计&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://on2171g4d.bkt.clouddn.com/jekyll-theme-vs.jpg&quot; alt=&quot;My Jekyll themes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比之前漂亮不少吧，下面聊聊H2O的新特性。&lt;/p&gt;

&lt;h2 id=&quot;新特性&quot;&gt;新特性&lt;/h2&gt;

&lt;h3 id=&quot;主题配色&quot;&gt;主题配色&lt;/h3&gt;

&lt;p&gt;支持两种主题配色——蓝色和粉色。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/screenshot/jekyll-theme-h2o-themecolor.jpg?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;侧边栏&quot;&gt;侧边栏&lt;/h3&gt;

&lt;p&gt;相比自己上一个版本的博客主题，首页增加了侧边栏，方便展示博主的个人信息和文章标签。&lt;/p&gt;

&lt;h3 id=&quot;社交图标&quot;&gt;社交图标&lt;/h3&gt;

&lt;p&gt;使用阿里的图标管理平台&lt;a href=&quot;http://iconfont.cn/&quot;&gt;Iconfont&lt;/a&gt;整理了一套&lt;strike&gt;墙内外&lt;/strike&gt;常用的社交图标，包括微博、知乎、掘金、简书、Github等十多个网站，鼠标悬停会显示该站的主题色。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-snstext.jpg&quot; alt=&quot;social iconfont&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;前后文导航&quot;&gt;前后文导航&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-nextpostnav.png&quot; alt=&quot;Next post navigator&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;自定义文章封面&quot;&gt;自定义文章封面&lt;/h3&gt;

&lt;p&gt;在Markdown的&lt;a href=&quot;http://jekyll.com.cn/docs/frontmatter/&quot;&gt;文章头信息&lt;/a&gt;里添加cover参数来配置文章的封面图片，如果没有配置封面，则默认【主题色+底纹】的组合作为文章封面。值得一提的是，H2O有两种（粉、蓝）主题色和六种底纹（电路板、食物、云海、钻石等等）供你选择。&lt;/p&gt;

&lt;h3 id=&quot;头图个性化底纹&quot;&gt;头图个性化底纹&lt;/h3&gt;

&lt;p&gt;在没有图片的情况下单纯显示颜色会不会太无趣了点？于是想到了加入底纹元素，底纹素材是SVG格式的（保存在css样式里），加载比图片快很多。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-headerpatterns.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;代码高亮&quot;&gt;代码高亮&lt;/h3&gt;

&lt;p&gt;模板引入了&lt;a href=&quot;http://prismjs.com&quot;&gt;Prism.js&lt;/a&gt;，一款轻量、可扩展的代码语法高亮库。&lt;/p&gt;

&lt;p&gt;很多知名网站如&lt;a href=&quot;https://developer.mozilla.org/&quot;&gt;MDN&lt;/a&gt;、&lt;a href=&quot;https://css-tricks.com/&quot;&gt;css-tricks&lt;/a&gt;也在用它，JavaScript 之父 &lt;a href=&quot;https://brendaneich.com/&quot;&gt;Brendan Eich&lt;/a&gt; 也在个人博客上使用。&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;red&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;遵循 &lt;a href=&quot;https://www.w3.org/TR/html5/grouping-content.html#the-pre-element&quot;&gt;HTML5&lt;/a&gt; 标准，Prism 使用语义化的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; 元素和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;code&amp;gt;&lt;/code&gt; 元素来标记代码区块：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;pre&amp;gt;&amp;lt;code class=&quot;language-css&quot;&amp;gt;p { color: red }&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在Markdown中你可以这样写：&lt;/p&gt;

&lt;pre&gt;
```css
   p { color: red }
```
&lt;/pre&gt;

&lt;p&gt;支持语言：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTML&lt;/li&gt;
  &lt;li&gt;CSS&lt;/li&gt;
  &lt;li&gt;Sass&lt;/li&gt;
  &lt;li&gt;JavaScript&lt;/li&gt;
  &lt;li&gt;CoffeeScript&lt;/li&gt;
  &lt;li&gt;Java&lt;/li&gt;
  &lt;li&gt;C-like&lt;/li&gt;
  &lt;li&gt;Swift&lt;/li&gt;
  &lt;li&gt;PHP&lt;/li&gt;
  &lt;li&gt;Go&lt;/li&gt;
  &lt;li&gt;Python&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;第三方评论&quot;&gt;第三方评论&lt;/h3&gt;

&lt;p&gt;由于多说关闭，又对国内其他第三方评论插件无感，所以将&lt;a href=&quot;https://disqus.com/&quot;&gt;Disqus&lt;/a&gt;列为首选（目前模板也只提供了这个），请自备梯子。&lt;/p&gt;

&lt;h3 id=&quot;移动端优化&quot;&gt;移动端优化&lt;/h3&gt;

&lt;p&gt;响应式设计，对手机和平板等移动设备做了优化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-realm.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;关于阅读体验&quot;&gt;关于阅读体验&lt;/h3&gt;

&lt;p&gt;我认为在内容质量相同的情况下，出色的沉浸式阅读体验是博客的核心。&lt;/p&gt;

&lt;p&gt;H2O在这方面还有很多需要完善的地方，比如：&lt;strike&gt;代码高亮&lt;/strike&gt;、夜间模式、查看大图…&lt;/p&gt;

&lt;h3 id=&quot;其他特性&quot;&gt;其他特性：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;网页标题SEO优化&lt;/li&gt;
  &lt;li&gt;标签索引，点击标签跳转到标签目录，即可查看对应的全部文章&lt;/li&gt;
  &lt;li&gt;漂亮&lt;/li&gt;
  &lt;li&gt;好看&lt;/li&gt;
  &lt;li&gt;美&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;

&lt;p&gt;本想趁这次机会将整站https化的，但折腾了半天发现弹性web托管并不支持，所以暂时搁置https的想法。另外，博客统计工具一直使用的是&lt;a href=&quot;https://tongji.baidu.com&quot;&gt;百度统计&lt;/a&gt;，这次新增了Google Analytics。&lt;/p&gt;

&lt;p&gt;这次从0到1，独自设计、开发再到发布大约用了一周时间，也算完成一个小小的开源项目了，后续也将持续完善和更新，欢迎&lt;a href=&quot;https://github.com/kaeyleo/jekyll-theme-H2O&quot;&gt;Star&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Tue, 18 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/18/new-theme-h2o.html</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/18/new-theme-h2o.html</guid>
        
        <category>jekyll</category>
        
        <category>前端开发</category>
        
        <category>设计</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Hello Jekyll</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Transform your plain text into static websites and blogs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;welcome&quot;&gt;Welcome&lt;/h3&gt;

&lt;p&gt;This site aims to be a comprehensive guide to Jekyll. We’ll cover topics such as getting your site up and running, creating and managing your content, customizing the way your site works and looks, deploying to various environments, and give you some advice on participating in the future development of Jekyll itself.&lt;/p&gt;

&lt;h3 id=&quot;so-what-is-jekyll-exactlypermalink&quot;&gt;So what is Jekyll, exactly?Permalink&lt;/h3&gt;

&lt;p&gt;Jekyll is a simple, blog-aware, static site generator. It takes a template directory containing raw text files in various formats, runs it through a converter (like &lt;a href=&quot;https://daringfireball.net/projects/markdown/&quot;&gt;Markdown&lt;/a&gt;) and our &lt;a href=&quot;https://github.com/Shopify/liquid/wiki&quot;&gt;Liquid&lt;/a&gt; renderer, and spits out a complete, ready-to-publish static website suitable for serving with your favorite web server. Jekyll also happens to be the engine behind GitHub Pages, which means you can use Jekyll to host your project’s page, blog, or website from GitHub’s servers for free.&lt;/p&gt;

&lt;h3 id=&quot;helpful-hintspermalink&quot;&gt;Helpful HintsPermalink&lt;/h3&gt;

&lt;p&gt;Throughout this guide there are a number of small-but-handy pieces of information that can make using Jekyll easier, more interesting, and less hazardous. Here’s what to look out for.&lt;/p&gt;

&lt;h3 id=&quot;video-test&quot;&gt;Video Test&lt;/h3&gt;

&lt;iframe type=&quot;text/html&quot; width=&quot;100%&quot; height=&quot;385&quot; src=&quot;http://www.youtube.com/embed/gfmjMWjn-Xg&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;
</description>
        <pubDate>Tue, 18 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/18/hello-jekyll.html</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/18/hello-jekyll.html</guid>
        
        <category>jekyll</category>
        
        
      </item>
    
  </channel>
</rss>
